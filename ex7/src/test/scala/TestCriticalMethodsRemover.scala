import analyses.D1_CriticalMethodsRemover.CriticalMethodsRemover
import analyses.D1_CriticalMethodsRemover.modify.FileIO
import data.{IgnoredCall, SelectedMethodsOfClass}
import org.opalj.br.analyses.Project
import org.opalj.br.instructions.Instruction
import org.opalj.br.{ClassFile, ObjectType}
import org.opalj.log.{DevNullLogger, GlobalLogContext, OPALLogger}
import org.scalatest.funsuite.AnyFunSuite
import org.slf4j.{Logger, LoggerFactory}
import play.api.libs.json.Json
import util.JsonIO

import java.io.{File, IOException}
import java.nio.file.attribute.BasicFileAttributes
import java.nio.file.{FileVisitResult, Files, Path, SimpleFileVisitor}

class TestCriticalMethodsRemover extends AnyFunSuite {
  /* Initializations */
  private val jsonIO = new JsonIO()
  private val logger: Logger = LoggerFactory.getLogger("TestCriticalMethodsRemover")
  private val baseOutputPath = "src/test/analysis_4.1"
  private def outputPath(testNumber: Int): String = s"$baseOutputPath.$testNumber"

  // Mute output from OPAL
  // As this test is only loading a small project, the console output is not really needed
  OPALLogger.updateLogger(GlobalLogContext, DevNullLogger)

  /**
   * Case: yget_nset
   * Description: getSecurityManager remains, setSecurityManager is removed
   * Only setSecurityManager is marked as critical, getSecurityManager is allowed (not critical)
   */
  test("Case: yget_nset -> only set should be removed") {
    val currentOutputPath = outputPath(1)
    logger.info("Running case yget_nset -> only set should be removed")

    val jsonConfig = Json.obj(
      "projectJars" -> Json.arr("src/test/4.1.1_testFiles/ExampleWithSecurityManager.jar"),
      "libraryJars" -> Json.arr(),
      "resultsOutputPath" -> currentOutputPath,
      "criticalMethodsRemover" -> Json.obj(
        "execute" -> true,
        "criticalMethods" -> Json.toJson(List[SelectedMethodsOfClass](
          SelectedMethodsOfClass("java.lang.System", List("setSecurityManager"))
        )),
        "ignore" -> "DEFAULT"
      )
    )
    val config = jsonIO.readStaticAnalysisConfig(jsonConfig, currentOutputPath)
    val criticalMethodsRemover = new CriticalMethodsRemover(config.criticalMethodsRemover.execute)
    criticalMethodsRemover.executeAnalysis(config)
    logger.info("Reading analysis results...")
    logger.info("Starting with generated results json file...")
    val result = FileIO.readJsonResult(s"$currentOutputPath/4a_CriticalMethodsRemover/results.json")
    assert(result.head.removedCalls.exists(_.targetMethod == "setSecurityManager"))
    assert(!result.head.removedCalls.exists(_.targetMethod == "getSecurityManager"))
    assert(!result.head.ignored)
    assert(result.head.bytecodeVerified)

    logger.info("Now checking bytecode generated by the analysis...")
    val instructionsOpt = loadMainMethodBytecode(1)
    assert(instructionsOpt.isDefined, "Main class or main method not found")
    val instructions = instructionsOpt.get
    val nops = instructions.slice(31, 34) // Approximate position of removed setSecurityManager call
    logger.info("Bytecode (yget_nset):")
    printInstructions(instructions)
    // Assert that the sliced range contains only NOPs
    assert(nops.forall(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))

    logger.info("Case yget_nset finished successfully")
    logger.info("Cleaning up results from previous test run...")
    cleanUpResultsFolder(1)
    logger.info("Cleanup complete.")
  }

  /**
   * Case: nget_yset
   * Description: setSecurityManager remains, getSecurityManager is removed
   * Only getSecurityManager is marked as critical, setSecurityManager is allowed (not critical)
   */
  test("Case: nget_yset -> only get should be removed") {
    val currentOutputPath = outputPath(2)
    logger.info("Running case nget_yset -> only get should be removed")

    val jsonConfig = Json.obj(
      "projectJars" -> Json.arr("src/test/4.1.1_testFiles/ExampleWithSecurityManager.jar"),
      "libraryJars" -> Json.arr(),
      "resultsOutputPath" -> currentOutputPath,
      "criticalMethodsRemover" -> Json.obj(
        "execute" -> true,
        "criticalMethods" -> Json.toJson(List[SelectedMethodsOfClass](
          SelectedMethodsOfClass("java.lang.System", List("getSecurityManager"))
        )),
        "ignore" -> "DEFAULT"
      )
    )
    val config = jsonIO.readStaticAnalysisConfig(jsonConfig, currentOutputPath)
    val criticalMethodsRemover = new CriticalMethodsRemover(config.criticalMethodsRemover.execute)
    criticalMethodsRemover.executeAnalysis(config)
    logger.info("Reading analysis results...")
    logger.info("Starting with generated results json file...")
    val result = FileIO.readJsonResult(s"$currentOutputPath/4a_CriticalMethodsRemover/results.json")
    assert(result.head.removedCalls.exists(_.targetMethod == "getSecurityManager"))
    assert(!result.head.removedCalls.exists(_.targetMethod == "setSecurityManager"))
    assert(!result.head.ignored)
    assert(result.head.bytecodeVerified)

    logger.info("Now checking bytecode generated by the analysis...")
    val instructionsOpt = loadMainMethodBytecode(2)
    assert(instructionsOpt.isDefined, "Main class or main method not found")
    val instructions = instructionsOpt.get
    val nops = instructions.slice(37, 40) // Approximate position of removed getSecurityManager call
    logger.info("Bytecode (nget_yset):")
    printInstructions(instructions)
    // Assert that the sliced range contains only NOPs
    assert(nops.forall(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))

    logger.info("Case nget_yset finished successfully")

    logger.info("Cleaning up results from previous test run...")
    cleanUpResultsFolder(2)
    logger.info("Cleanup complete.")
  }

  /**
   * Case: nget_nset
   * Description: both getSecurityManager and setSecurityManager are removed
   * Both methods are marked as critical and neither is ignored
   */
  test("Case: nget_nset -> both should be removed") {
    val currentOutputPath = outputPath(3)
    logger.info("Running case yget_yset -> both should be removed")

    val jsonConfig = Json.obj(
      "projectJars" -> Json.arr("src/test/4.1.1_testFiles/ExampleWithSecurityManager.jar"),
      "libraryJars" -> Json.arr(),
      "resultsOutputPath" -> currentOutputPath,
      "criticalMethodsRemover" -> Json.obj(
        "execute" -> true,
        "criticalMethods" -> Json.toJson(List[SelectedMethodsOfClass](
          SelectedMethodsOfClass("java.lang.System", List("getSecurityManager", "setSecurityManager"))
        )),
        "ignore" -> "DEFAULT"
      )
    )
    val config = jsonIO.readStaticAnalysisConfig(jsonConfig, currentOutputPath)
    val criticalMethodsRemover = new CriticalMethodsRemover(config.criticalMethodsRemover.execute)
    criticalMethodsRemover.executeAnalysis(config)

    logger.info("Reading analysis results...")
    logger.info("Starting with generated results json file...")
    val result = FileIO.readJsonResult(s"$currentOutputPath/4a_CriticalMethodsRemover/results.json")
    val removed = result.head.removedCalls.map(_.targetMethod).toSet
    assert(removed == Set("getSecurityManager", "setSecurityManager"))
    assert(!result.head.ignored)
    assert(result.head.bytecodeVerified)

    logger.info("Now checking bytecode generated by the analysis...")
    val instructionsOpt = loadMainMethodBytecode(3)
    assert(instructionsOpt.isDefined)
    val instructions = instructionsOpt.get
    val setNops = instructions.slice(31, 34) // Approx. position of setSecurityManager
    val getNops = instructions.slice(37, 40) // Approx. position of getSecurityManager
    logger.info("Bytecode (nget_nset):")
    printInstructions(instructions)
    // Assert both are NOPs
    assert(setNops.forall(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))
    assert(getNops.forall(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))

    logger.info("Case nget_nset finished successfully")

    logger.info("Cleaning up results from previous test run...")
    cleanUpResultsFolder(3)
    logger.info("Cleanup complete.")
  }

  /**
   * Case: yget_yset
   * Description: both getSecurityManager and setSecurityManager remain
   * Both methods are marked as critical but are explicitly ignored via ignoreCalls
   */
  test("Case: yget_yset -> both should be ignored") {
    val currentOutputPath = outputPath(4)
    logger.info("Running case yget_yset -> both should be ignored")

    val jsonConfig = Json.obj(
      "projectJars" -> Json.arr("src/test/4.1.1_testFiles/ExampleWithSecurityManager.jar"),
      "libraryJars" -> Json.arr(),
      "resultsOutputPath" -> currentOutputPath,
      "criticalMethodsRemover" -> Json.obj(
        "execute" -> true,
        "criticalMethods" -> Json.toJson(List[SelectedMethodsOfClass](
          SelectedMethodsOfClass("java.lang.System", List("getSecurityManager", "setSecurityManager"))
        )),
        "ignore" -> List(
          IgnoredCall("Main", "main", "java.lang.System", "getSecurityManager"),
          IgnoredCall("Main", "main", "java.lang.System", "setSecurityManager")
        )
      )
    )
    val config = jsonIO.readStaticAnalysisConfig(jsonConfig, currentOutputPath)
    val criticalMethodsRemover = new CriticalMethodsRemover(config.criticalMethodsRemover.execute)
    criticalMethodsRemover.executeAnalysis(config)

    logger.info("Reading analysis results...")
    logger.info("Starting with generated results json file...")
    val result = FileIO.readJsonResult(s"$currentOutputPath/4a_CriticalMethodsRemover/results.json")
    assert(result.head.removedCalls.isEmpty)
    assert(result.head.ignored)
    assert(result.head.bytecodeVerified)

    logger.info("Now checking bytecode generated by the analysis...")
    val instructionsOpt = loadMainMethodBytecode(4)
    assert(instructionsOpt.isDefined)
    val instructions = instructionsOpt.get
    val checkRange = instructions.slice(30, 41) // Scan typical area where critical calls may exist
    logger.info("Bytecode (yget_yset):")
    printInstructions(instructions)
    // Assert that no NOP instructions are found
    assert(!checkRange.exists(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))

    logger.info("Case yget_yset finished successfully")

    logger.info("Cleaning up results from previous test run...")
    cleanUpResultsFolder(4)
    logger.info("Cleanup complete.")
  }

  /* Helper methods */


  /** Helper method to automatically delete the files created in the results folder */
  private def cleanUpResultsFolder(testNumber: Int): Unit = {
    // Change path on your own risk! Here, the tests will NOT ask you before deleting the contents of the folder!
    val pathObject = Path.of(outputPath(testNumber)).toAbsolutePath
    Files.walkFileTree(pathObject, new SimpleFileVisitor[Path]() {
      override def visitFile(file: Path, attrs: BasicFileAttributes): FileVisitResult = {
        Files.delete(file)
        FileVisitResult.CONTINUE
      }

      override def postVisitDirectory(dir: Path, exc: IOException): FileVisitResult = {
        Files.delete(dir)
        FileVisitResult.CONTINUE
      }
    })
  }

  /** Loads the bytecode (instruction array) of the main method from a compiled .class file */
  private def loadMainMethodBytecode(testNumber: Int): Option[Array[Instruction]] = {
    val project = Project(new File(s"${outputPath(testNumber)}/4a_CriticalMethodsRemover/modifiedClasses"))
    val mainClassOpt: Option[ClassFile] = project.classFile(ObjectType("Main"))

    mainClassOpt.flatMap { cf =>
      cf.methods.find(_.name == "main").flatMap(_.body).map(_.instructions)
    }
  }

  /** Prints the bytecode instructions of a class file */
  private def printInstructions(instructions: Array[Instruction]): Unit = {
    instructions.zipWithIndex.foreach {
      case (i, idx) =>
        val display = if (i == null) "null" else i.mnemonic
        logger.info(f"$idx%03d: $display")
    }
  }
}
