package analyses.F_ArchitectureValidator

import analyses.SubAnalysis
import com.typesafe.scalalogging.Logger
import configs.StaticAnalysisConfig
import data.{ArchitectureSpec, Dependency, RecursiveWarnings, Rule}
import helpers.{ArchitectureJsonIO, ArchitectureValidation}
import util.ProjectInitializer

import scala.util.Random

class ArchitectureValidator(override val shouldExecute: Boolean) extends SubAnalysis {

  /** Logger used inside this sub-analysis */
  override val logger: Logger = Logger("ArchitectureValidator")
  /** The name of the sub-analysis */
  override val analysisName: String = "Architecture Validator"
  /** The number of the sub-analysis */
  override val analysisNumber: String = "6"
  /** Name of the folder where this sub-analysis will put their results in */
  override val outputFolderName: String = "6_ArchitectureValidator"

  override def executeAnalysis(config: StaticAnalysisConfig): Unit = {
    val analysisConfig = config.architectureValidator
    // Print out config
    val totalNumberOfRules = {
      def countRules(rules: List[Rule]): Int = {
        rules.length + rules.map { rule => if (rule.except.isDefined) countRules(rule.except.get) else 0 }.sum
      }

      countRules(analysisConfig.rules)
    }
    val onlyMethodAndFieldAccessesString = if (analysisConfig.onlyMethodAndFieldAccesses)
      "Only considering dependencies resulting from method and field accesses."
    else "Considering all dependencies inside the project."
    logger.info(
      s"""Configuration:
         |  - Only count method and field accesses: ${analysisConfig.onlyMethodAndFieldAccesses}
         |     --> $onlyMethodAndFieldAccessesString
         |  - Default rule: ${analysisConfig.defaultRule}
         |  - Number of additional base rules: ${analysisConfig.rules.length}
         |  - Total number of additional rules: $totalNumberOfRules""".stripMargin
    )

    // Set up project
    logger.info("Initializing OPAL project...")
    val project = ProjectInitializer.setupProject(
      logger = logger,
      cpFiles = config.projectJars,
      libcpFiles = config.libraryJars
    )
    val spec = ArchitectureSpec(
      defaultRule = analysisConfig.defaultRule,
      rules = analysisConfig.rules
    )
    logger.info("Project initialization finished. Starting analysis on project...")

    val report = ArchitectureValidation.analyze(logger, project, spec, config)

    logger.info("Architecture validation finished.")

    val reportOutputDir = s"${config.resultsOutputPath}/$outputFolderName/architecture_report.json"
    ArchitectureJsonIO.writeReport(report, reportOutputDir)
    logger.info(s"Wrote json report to $reportOutputDir.")

    logger.info(s"Found ${report.violations.size} dependency violations.")

    // Print summary
    if (report.violations.nonEmpty) {
      logger.info(s"Violations found:${buildViolationsString(report.violations, 5)}")
    }

    if (report.warnings.warnings.nonEmpty || report.warnings.innerWarnings.nonEmpty) {
      logger.warn(s"Generated a total of ${report.warningsCount} warnings regarding the specification.")
      logger.warn(s"Specification warnings:\n${prettyPrintWarnings(report.warnings)}")
    }
  }

  /**
   * Builds a readable string out of the [[RecursiveWarnings]] generated during the specification validation.
   *
   * @param warnings The warning(s) to print out.
   * @param indent   Depth for the warning.
   * @return String to output to the log.
   */
  private def prettyPrintWarnings(warnings: RecursiveWarnings, indent: String = ""): String = {
    val stringBuilder = new StringBuilder()
    warnings.warnings.foreach { message => stringBuilder.append(s"$indent- $message\n") }
    warnings.innerWarnings.foreach { case (rule, nestedWarnings) =>
      stringBuilder.append(s"$indent$rule:\n")
      stringBuilder.append(prettyPrintWarnings(nestedWarnings, indent + "  ") + "\n")
    }
    stringBuilder.toString
  }

  /**
   * Builds a string that can be used to print some sample violations in the logs.
   *
   * Also sorts the samples alphabetically.
   *
   * @param violations Violations generated by the analysis.
   * @param k The number of samples to show. When violations contains less than k elements, just show all elements.
   * @return String that can be outputted in the logs.
   */
  //noinspection SameParameterValue
  private def buildViolationsString(
                                     violations: List[Dependency],
                                     k: Int): String = {
    val samples = Random.shuffle(violations).take(k)
    if (samples.isEmpty) return "None"
    val mainString = samples.map { sample =>
      val fromPackage = sample.fromPackage
      val fromClass = sample.fromClass
      val toPackage = sample.toPackage
      val toClass = sample.toClass
      val accessType = sample.accessType.name
      s"$fromPackage.$fromClass -> $toPackage.$toClass ($accessType)"
    }.sorted.mkString("\n  - ", "\n  - ", "")
    val moreViolations = if (violations.size > k) s"\n... and ${violations.size - k} more violations"
    else ""

    s"$mainString$moreViolations"
  }
}