package analyses.C_TPLUsageAnalyzer.analysis

import org.opalj.br.analyses.Project
import org.opalj.br.{ClassFile, Method}
import org.opalj.tac.cg.CallGraph

import java.io.File
import java.net.{URL, URLDecoder}
import java.nio.charset.StandardCharsets
import scala.collection.mutable

/**
 * Main object responsible for the static analysis of TPL method usage.
 */
object TPLMethodUsageAnalysis {

  /**
   * Function that does the main analysis of this application.
   *
   * @param project The OPAL project with all loaded class files
   * @param callGraph Call graph generated from the project
   * @param tplFiles List of third party library JAR files which should be analyzed.
   * @param config Configuration of analysis
   * @return List containing results for each library
   */
  def analyze(
                project: Project[URL],
                callGraph: CallGraph,
                tplFiles: List[File],
                config: AnalysisConfig
              ): List[TPLInfo] = {
    // Step 1: Assign each library class file the corresponding library jar
    val libraryPaths = tplFiles.map {
      file => (file.getAbsolutePath.replace('\\', '/'), file.getPath.replace('\\', '/'))
    }

    val libClasses = mutable.Map.empty[ClassFile, (String, mutable.Set[Method])]
    project.libraryClassFilesWithSources.foreach { case (classFile, source) =>
      val classPath = URLDecoder.decode(source.getPath, StandardCharsets.UTF_8.name())
      val libPath = libraryPaths.collectFirst {case jarPath if classPath.contains(jarPath._1) => jarPath._2}.getOrElse("<Unknown library>")
      libClasses += (classFile -> (libPath, mutable.Set.empty[Method]))
    }

    // Step 2: Go through all reachable methods (generated by the call graph)
    callGraph.reachableMethods.foreach { context =>
      // Step 2.1: Check type of declaredMethod
      val declaredMethod = context.method
      val methods = mutable.ListBuffer.empty[Method]
      // Virtual declared method: Method where original definition unavailable. Not usable for analysis
      if (declaredMethod.isVirtualOrHasSingleDefinedMethod && !declaredMethod.hasSingleDefinedMethod) {/* Ignore */}
      // Single defined method: No ambiguity of which method definition will be called, interesting for analysis
      else if (declaredMethod.hasSingleDefinedMethod) methods += declaredMethod.definedMethod
      // Multiple defined methods: Multiple method definitions may be callable (and thus should each be added)
      else methods.addAll(declaredMethod.definedMethods)

      // Step 2.2: Add method as being used/accessed
      methods.foreach { method =>
        if (config.countAllMethods || method.isPublic) {
          libClasses.get(method.classFile).foreach { case (_, accessedMethods) =>
            accessedMethods.add(method)
          }
        }
      }
    }

    // Step 3: Count number of used methods and all methods in general
    val tplInfosMap = libraryPaths.map { case (_, library) =>
      library -> TPLInfo(library, 0, 0, 1.0)
    }.toMap

    // Should hopefully be always empty. Added in case of unexcepted behavior to prevent an exception.
    val unknownLibraryInfos = TPLInfo("<Unknown library> (Classes with no assigned library)", 0, 0, 1.0)

    // For each library class, at its total amount of methods and used methods
    libClasses.foreach { case classFile -> tuple =>
      val (library, accessedMethods) = tuple

      if (library.equals("<Unknown library>")) {
        val numberOfMethods = if (config.countAllMethods) classFile.methods.size
        else classFile.methods.count {method => method.isPublic }
        unknownLibraryInfos.totalMethods += numberOfMethods
        unknownLibraryInfos.usedMethods += accessedMethods.size
      }
      else {
        val tplInfo = tplInfosMap(library)

        val numberOfMethods = if (config.countAllMethods) classFile.methods.size
        else classFile.methods.count {method => method.isPublic }
        tplInfo.totalMethods += numberOfMethods
        tplInfo.usedMethods += accessedMethods.size
      }
    }
    tplInfosMap.foreach { case _ -> tplInfo =>
      if (tplInfo.totalMethods != 0) tplInfo.usageRatio = tplInfo.usedMethods.toDouble / tplInfo.totalMethods.toDouble
      else tplInfo.usageRatio = 1.0
    }

    // When some classes with no assigned library have been found, output the "Unknown library" library as well
    var tplInfos = tplInfosMap.values
    if (unknownLibraryInfos.totalMethods != 0 || unknownLibraryInfos.usedMethods != 0) tplInfos = tplInfos ++ Seq(unknownLibraryInfos)

    tplInfos.toList
  }
}