import com.typesafe.config.ConfigFactory
import org.opalj.log.{DevNullLogger, GlobalLogContext, OPALLogger}
import org.scalatest.funsuite.AnyFunSuite
import modify.FileIO
import org.opalj.br.{ClassFile, ObjectType}
import org.opalj.br.analyses.{ProgressManagement, Project}
import org.opalj.br.instructions.Instruction
import org.scalatest.BeforeAndAfterEach

import java.io.{File, IOException}
import java.nio.file.attribute.BasicFileAttributes
import java.nio.file.{FileVisitResult, Files, Path, SimpleFileVisitor}

class TestCriticalMethodsRemover extends AnyFunSuite with BeforeAndAfterEach {
  /* Initializations */

  // Mute output from OPAL
  // As this test is only loading a small project, the console output is not really needed
  OPALLogger.updateLogger(GlobalLogContext, DevNullLogger)

  // If there are remnants of a previous test run (e.g. when a test fails), delete folder
  if (new File("src/test/4.1.1_testFiles/resultFiles").exists) {
    println("Preparing test environment...")
    cleanUpResultsFolder()
  }

  override def afterEach(): Unit = {
    println("Cleaning up results from previous test run...")
    cleanUpResultsFolder()
    println("Cleanup complete.")
  }

  /**
   * Case: yget_nset
   * Description: getSecurityManager remains, setSecurityManager is removed
   * Only setSecurityManager is marked as critical, getSecurityManager is allowed (not critical)
   */
  test("Case: yget_nset -> only set should be removed") {
    println("Running case yget_nset -> only set should be removed")
    runAnalysis("src/test/4.1.1_testFiles/test_yget_nset.json")
    println("Reading analysis results...")
    println("Starting with generated results json file...")
    val result = FileIO.readJsonResult("src/test/4.1.1_testFiles/resultFiles/test_result.json")
    assert(result.head.removedCalls.exists(_.targetMethod == "setSecurityManager"))
    assert(!result.head.removedCalls.exists(_.targetMethod == "getSecurityManager"))
    assert(!result.head.ignored)
    assert(result.head.bytecodeVerified)

    println("Now checking bytecode generated by the analysis...")
    val instructionsOpt = loadMainMethodBytecode()
    assert(instructionsOpt.isDefined, "Main class or main method not found")
    val instructions = instructionsOpt.get
    val nops = instructions.slice(31, 34) // Approximate position of removed setSecurityManager call
    println("Bytecode (yget_nset):")
    printInstructions(instructions)
    // Assert that the sliced range contains only NOPs
    assert(nops.forall(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))

    println("Case yget_nset finished successfully")
  }

  /**
   * Case: nget_yset
   * Description: setSecurityManager remains, getSecurityManager is removed
   * Only getSecurityManager is marked as critical, setSecurityManager is allowed (not critical)
   */
  test("Case: nget_yset -> only get should be removed") {
    println("Running case nget_yset -> only get should be removed")
    runAnalysis("src/test/4.1.1_testFiles/test_nget_yset.json")
    println("Reading analysis results...")
    println("Starting with generated results json file...")
    val result = FileIO.readJsonResult("src/test/4.1.1_testFiles/resultFiles/test_result.json")
    assert(result.head.removedCalls.exists(_.targetMethod == "getSecurityManager"))
    assert(!result.head.removedCalls.exists(_.targetMethod == "setSecurityManager"))
    assert(!result.head.ignored)
    assert(result.head.bytecodeVerified)

    println("Now checking bytecode generated by the analysis...")
    val instructionsOpt = loadMainMethodBytecode()
    assert(instructionsOpt.isDefined, "Main class or main method not found")
    val instructions = instructionsOpt.get
    val nops = instructions.slice(37, 40) // Approximate position of removed getSecurityManager call
    println("Bytecode (nget_yset):")
    printInstructions(instructions)
    // Assert that the sliced range contains only NOPs
    assert(nops.forall(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))

    println("Case nget_yset finished successfully")
  }

  /**
   * Case: nget_nset
   * Description: both getSecurityManager and setSecurityManager are removed
   * Both methods are marked as critical and neither is ignored
   */
  test("Case: nget_nset -> both should be removed") {
    println("Running case yget_yset -> both should be removed")
    runAnalysis("src/test/4.1.1_testFiles/test_nget_nset.json")
    println("Reading analysis results...")
    println("Starting with generated results json file...")
    val result = FileIO.readJsonResult("src/test/4.1.1_testFiles/resultFiles/test_result.json")
    val removed = result.head.removedCalls.map(_.targetMethod).toSet
    assert(removed == Set("getSecurityManager", "setSecurityManager"))
    assert(!result.head.ignored)
    assert(result.head.bytecodeVerified)

    println("Now checking bytecode generated by the analysis...")
    val instructionsOpt = loadMainMethodBytecode()
    assert(instructionsOpt.isDefined)
    val instructions = instructionsOpt.get
    val setNops = instructions.slice(31, 34) // Approx. position of setSecurityManager
    val getNops = instructions.slice(37, 40) // Approx. position of getSecurityManager
    println("Bytecode (nget_nset):")
    printInstructions(instructions)
    // Assert both are NOPs
    assert(setNops.forall(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))
    assert(getNops.forall(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))

    println("Case nget_nset finished successfully")
  }

  /**
   * Case: yget_yset
   * Description: both getSecurityManager and setSecurityManager remain
   * Both methods are marked as critical but are explicitly ignored via ignoreCalls
   */
  test("Case: yget_yset -> both should be ignored") {
    println("Running case yget_yset -> both should be ignored")
    runAnalysis("src/test/4.1.1_testFiles/test_yget_yset.json")
    println("Reading analysis results...")
    println("Starting with generated results json file...")
    val result = FileIO.readJsonResult("src/test/4.1.1_testFiles/resultFiles/test_result.json")
    assert(result.head.removedCalls.isEmpty)
    assert(result.head.ignored)
    assert(result.head.bytecodeVerified)

    println("Now checking bytecode generated by the analysis...")
    val instructionsOpt = loadMainMethodBytecode()
    assert(instructionsOpt.isDefined)
    val instructions = instructionsOpt.get
    val checkRange = instructions.slice(30, 41) // Scan typical area where critical calls may exist
    println("Bytecode (yget_yset):")
    printInstructions(instructions)
    // Assert that no NOP instructions are found
    assert(!checkRange.exists(i => i != null && i.mnemonic.equalsIgnoreCase("nop")))

    println("Case yget_yset finished successfully")
  }

  /* Helper methods */

  /** Lets the analysis run automatically with the given config and lets it create the result files */
  private def runAnalysis(configPath: String): Unit = {
    CriticalMethodsRemover.config = Some(FileIO.readConfig(configPath))
    val project = CriticalMethodsRemover.setupProject(
      Iterable.empty[File],
      Iterable.empty[File],
      completelyLoadLibraries = false,
      ConfigFactory.load
    )(GlobalLogContext)
    CriticalMethodsRemover.analyze(project, Seq.empty[String], ProgressManagement.None)
  }


  /** Helper method to automatically delete the files created in the results folder */
  private def cleanUpResultsFolder(): Unit = {
    // Change path on your own risk! Here, the tests will NOT ask you before deleting the contents of the folder!
    val pathObject = Path.of("src/test/4.1.1_testFiles/resultFiles").toAbsolutePath
    Files.walkFileTree(pathObject, new SimpleFileVisitor[Path]() {
      override def visitFile(file: Path, attrs: BasicFileAttributes): FileVisitResult = {
        Files.delete(file)
        FileVisitResult.CONTINUE
      }

      override def postVisitDirectory(dir: Path, exc: IOException): FileVisitResult = {
        Files.delete(dir)
        FileVisitResult.CONTINUE
      }
    })
  }

  /** Loads the bytecode (instruction array) of the main method from a compiled .class file */
  private def loadMainMethodBytecode(): Option[Array[Instruction]] = {
    val project = Project(new File("src/test/4.1.1_testFiles/resultFiles"))
    val mainClassOpt: Option[ClassFile] = project.classFile(ObjectType("Main"))

    mainClassOpt.flatMap { cf =>
      cf.methods.find(_.name == "main").flatMap(_.body).map(_.instructions)
    }
  }

  /** Prints the bytecode instructions of a class file */
  private def printInstructions(instructions: Array[Instruction]): Unit = {
    instructions.zipWithIndex.foreach {
      case (i, idx) =>
        val display = if (i == null) "null" else i.mnemonic
        println(f"$idx%03d: $display")
    }
  }
}
